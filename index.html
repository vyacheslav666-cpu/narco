<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Симулятор солевого</title>
    <style>
        body { text-align: center; font-family: Arial, sans-serif; margin: 0; padding: 20px; background: #222; }
        canvas { background: #f4f4f4; display: block; margin: 20px auto; border: 2px solid #444; }
        .info { color: white; margin-bottom: 10px; }
    </style>
</head>
<body>
    <div class="info">Нажмите ПРОБЕЛ, чтобы прыгать</div>
    <canvas id="gameCanvas" width="800" height="300"></canvas>
	
<audio id="bgMusic" loop>
    Ваш браузер не поддерживает аудио.
</audio>

<audio id="pickupSound">
    <source src="music/pick.mp3" type="audio/mpeg">
</audio>

<audio id="looseSound">
    <source src="music/loose.mp3" type="audio/mpeg">
</audio>

<audio id="jumpSound">
    <source src="music/jump.mp3" type="audio/mpeg">
</audio>

<audio id="rareItemSound">
    <source src="music/rareItem.mp3" type="audio/mpeg">
</audio>

<script>
    let musicStarted = false; 
    const musicTracks = [
        "music/background0.mp3",
        "music/background1.mp3",
        "music/background2.mp3",
        "music/background3.mp3",
        "music/background4.mp3"
    ];

    document.addEventListener("keydown", (event) => {
        if (event.code === "Space" && !musicStarted) { 
            event.preventDefault();  
            const bgMusic = document.getElementById("bgMusic");

            // Выбираем случайный трек
            const randomTrack = musicTracks[Math.floor(Math.random() * musicTracks.length)];
            bgMusic.src = randomTrack;
            bgMusic.load(); // Загружаем новый источник перед воспроизведением
			
			bgMusic.volume = 0.7;
            bgMusic.play().then(() => {
                musicStarted = true; 
                console.log("Играет: " + randomTrack);
            }).catch(error => {
                console.log("Ошибка воспроизведения:", error);
            });
        }
    });
</script>





    <script>

	
	
        // Инициализация canvas
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
		
		// фоны
		const backgrounds = [
				"img/background0.png",
				"img/background1.png",
				"img/background2.png",
				"img/background3.png",
				"img/background4.png"
			];
			
		let currentBgIndex = 0; // Индекс текущего фона
        
        // Загрузка изображений
        const assets = {
            dino: new Image(),
            coin: new Image(),
            bg: new Image(),
			obstacle: new Image(),
			rareItem: new Image()

        };
        
        // Установка путей к изображениям 
        assets.dino.src = 'img/nark.png';
        assets.coin.src = 'img/klad.png';
        assets.bg.src = backgrounds[currentBgIndex]; 
		assets.obstacle.src = 'img/ment.png'
		assets.rareItem.src = 'img/super-klad.png';
        

        // Настройки игры
        let dino = {
            x: 100,
            y: 100,
            width: 80,
            height: 80,
            dy: 0,
            gravity: 1,
            jumpPower: -19,
            onGround: false
        };
        
        let obstacles = [];
        let items = [];
		let rareItems = [];
        let gameSpeed = 6;
        let score = 0;
        let isGameOver = false;
        let framesSinceLastObstacle = 0;
        let framesSinceLastItem = 0;
		
		// переменные для смены фона
		let bgTransition = {
			active: false,
			progress: 0, // 0-1
			duration: 60, // frames
			currentBg: null,
			nextBg: null
		};

		

        // Функции отрисовки
        function drawDino() {
            try {
                ctx.drawImage(assets.dino, dino.x, dino.y, dino.width, dino.height);
            } catch (e) {
                ctx.fillStyle = "green";
                ctx.fillRect(dino.x, dino.y, dino.width, dino.height);
            }
        }
        
        function drawObstacles() {
    obstacles.forEach(obstacle => {
        try {
            // Рисуем спрайт препятствия
            ctx.drawImage(
                assets.obstacle,
                obstacle.x,
                obstacle.y - obstacle.height + 40, // Корректировка позиции Y
                obstacle.width,
                obstacle.height
            );
        } catch (e) {
            // Фолбэк - красный прямоугольник
            ctx.fillStyle = "red";
            ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
        }
    });
}
        
        function drawItems() {
            items.forEach(item => {
                try {
                    ctx.drawImage(assets.coin, item.x, item.y, item.width, item.height);
                } catch (e) {
                    ctx.fillStyle = "gold";
                    ctx.beginPath();
                    ctx.arc(item.x + item.width/2, item.y + item.height/2, item.width/2, 0, Math.PI*2);
                    ctx.fill();
                }
            });
        }
		
		function drawRareItems() {
			rareItems.forEach(item => {
				try {
					ctx.drawImage(assets.rareItem, item.x, item.y, item.width, item.height);
				} catch (e) {
					ctx.fillStyle = "blue";
					ctx.fillRect(item.x, item.y, item.width, item.height);
				}
			});
		}
        
		//скорость
		function updateGameSpeed() {
    gameSpeed = 6 + Math.floor(score / 500); // Каждые 500 очков +1 к скорости
}
		// обновление фона
		function updateBackground() {
    const newBgIndex = Math.min(Math.floor(score / 1000), backgrounds.length - 1);
    
    if (newBgIndex > currentBgIndex && !bgTransition.active) {
        // Начинаем переход
        currentBgIndex = newBgIndex;
        bgTransition.active = true;
        bgTransition.progress = 0;
        bgTransition.currentBg = assets.bg;
        
        // Предзагружаем следующий фон
        const nextBg = new Image();
        nextBg.src = backgrounds[currentBgIndex];
        bgTransition.nextBg = nextBg;
    }
}	

// анимация смены фона
function drawBackground() {
    if (!bgTransition.active) {
        // Обычный режим - просто рисуем текущий фон
        try {
            ctx.drawImage(assets.bg, 0, 0, canvas.width, canvas.height);
        } catch (e) {
            ctx.fillStyle = "#87CEEB";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
    } else {
        // Режим перехода
        if (bgTransition.nextBg.complete) {
            // Рисуем оба фона с прозрачностью
            ctx.globalAlpha = 1 - bgTransition.progress;
            try {
                ctx.drawImage(bgTransition.currentBg, 0, 0, canvas.width, canvas.height);
            } catch (e) {
                ctx.fillStyle = "#87CEEB";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            ctx.globalAlpha = bgTransition.progress;
            try {
                ctx.drawImage(bgTransition.nextBg, 0, 0, canvas.width, canvas.height);
            } catch (e) {
                ctx.fillStyle = "#87CEEB";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            ctx.globalAlpha = 1;
            
            // Увеличиваем прогресс перехода
            bgTransition.progress += 1 / bgTransition.duration;
            
            // Если переход завершен
            if (bgTransition.progress >= 1) {
                bgTransition.active = false;
                assets.bg = bgTransition.nextBg;
            }
        } else {
            // Если новый фон еще не загрузился, рисуем старый
            try {
                ctx.drawImage(bgTransition.currentBg, 0, 0, canvas.width, canvas.height);
            } catch (e) {
                ctx.fillStyle = "#87CEEB";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }
    }
}

		
        // Основной игровой цикл
        function update() {
            if (isGameOver) return;
            
            // Очистка экрана
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Фон
            drawBackground();
			
			updateBackground(); 

            
            // Физика динозавра
            dino.dy += dino.gravity;
            dino.y += dino.dy;
            
            if (dino.y >= 200) {
                dino.y = 200;
                dino.dy = 0;
                dino.onGround = true;
            } else {
                dino.onGround = false;
            }
            
            // Генерация препятствий
            framesSinceLastObstacle++;
            if (framesSinceLastObstacle > 100 + Math.random() * 50) {
                obstacles.push({
                    x: canvas.width,
                    y: 250,
                    width: 60,
                    height: 80
                });
                framesSinceLastObstacle = 0;
            }
            
            // Генерация предметов`
            framesSinceLastItem++;
            if (framesSinceLastItem > 50 + Math.random() * 50) {
				const possibleHeights = [80, 120, 160]; // Разные возможные высоты
				items.push({
					x: canvas.width,
					y: possibleHeights[Math.floor(Math.random() * possibleHeights.length)],
					width: 50,
					height: 50
				});
				framesSinceLastItem = 0;
			}
			
			// Генерация редких предметов (реже обычных)
				if (Math.random() < 0.002) { // 2% шанс появления
					rareItems.push({
						x: canvas.width,
						y: Math.random() * 150 + 50,
						width: 60,
						height: 60
					});
					}
            
            // Движение объектов
            obstacles.forEach(obstacle => obstacle.x -= gameSpeed);
            items.forEach(item => item.x -= gameSpeed);
            rareItems.forEach(item => item.x -= gameSpeed);
			rareItems = rareItems.filter(item => item.x + item.width > 0);

			
			
            // Удаление вышедших за экран объектов
            obstacles = obstacles.filter(obstacle => obstacle.x + obstacle.width > 0);
            items = items.filter(item => item.x + item.width > 0);
            
            // Проверка столкновений
            checkCollisions();
            
            // Увеличение счета
            //score++;
            
            // Отрисовка
            drawDino();
            drawObstacles();
            drawItems();
			drawRareItems();
            
            // Отображение счета
            ctx.fillStyle = "white";
			ctx.font = "24px Arial bold";
			ctx.textAlign = "left";
			ctx.textBaseline = "top";

			// Чёрная обводка
			ctx.shadowColor = "black";
			ctx.shadowBlur = 0;
			ctx.shadowOffsetX = 2;
			ctx.shadowOffsetY = 2;

			// Рисуем текст
			ctx.fillText("Вы собрали " + score + " мг", 20, 30);

			// Убираем обводку, чтобы не влияла на другие элементы
			ctx.shadowOffsetX = 0;
			ctx.shadowOffsetY = 0;
            
			// обновление скорости
			updateGameSpeed()
			
            requestAnimationFrame(update);
        }
        
        function checkCollisions() {
    const pickupSound = document.getElementById("pickupSound");
	const looseSound = document.getElementById("looseSound");
	const rareItemSound = document.getElementById("rareItemSound");
	

    // Столкновение с препятствиями
    for (let obstacle of obstacles) {
        if (isColliding(dino, obstacle)) {
			looseSound.play().catch(e => console.log("Ошибка воспроизведения:", e));
            endGame();
            return;
        }
    }

    // Сбор предметов
    for (let i = items.length - 1; i >= 0; i--) {
        if (isColliding(dino, items[i])) {
            score += 50;
            items.splice(i, 1);
            
            // Воспроизводим звук подбора
            pickupSound.play().catch(e => console.log("Ошибка воспроизведения:", e));
        }
    }
	
	// сбор редких предметов
	for (let i = rareItems.length - 1; i >= 0; i--) {
    if (isColliding(dino, rareItems[i])) {
        score += 200; // Даем больше очков за редкий предмет
        rareItems.splice(i, 1);
		
		// Воспроизводим звук подбора
            rareItemSound.play().catch(e => console.log("Ошибка воспроизведения:", e));
    }
}

	
}

        
        function isColliding(a, b) {
            return a.x < b.x + b.width &&
                   a.x + a.width > b.x &&
                   a.y < b.y + b.height &&
                   a.y + a.height > b.y;
        }
        
        function endGame() {
            isGameOver = true;
            
            // Полупрозрачная подложка
            ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Текст
            ctx.fillStyle = "white";
            ctx.font = "36px Arial";
            ctx.textAlign = "center";
            ctx.fillText("Игра окончена!", canvas.width/2, canvas.height/2 - 20);
            ctx.fillText("Счет: " + score + " милиграмм", canvas.width/2, canvas.height/2 + 20);
            
            // Кнопка рестарта
            ctx.fillStyle = "red";
            ctx.fillRect(canvas.width/2 - 100, canvas.height/2 + 60, 200, 40);
            ctx.fillStyle = "white";
            ctx.font = "20px Arial";
            ctx.fillText("Играть снова", canvas.width/2, canvas.height/2 + 75);
            
            canvas.addEventListener("click", restartGame);
        }
        
        function restartGame(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (x >= canvas.width/2 - 100 && x <= canvas.width/2 + 100 &&
                y >= canvas.height/2 + 40 && y <= canvas.height/2 + 90) {
                location.reload();
            }
        }
        
        // Управление
        document.addEventListener("keydown", function(e) {
    if (e.code === "Space" && dino.onGround) {
        dino.dy = dino.jumpPower;

        // Воспроизводим звук прыжка
        const jumpSound = document.getElementById("jumpSound");
        jumpSound.currentTime = 0; // Чтобы звук можно было проигрывать быстро подряд
        jumpSound.play().catch(e => console.log("Ошибка воспроизведения:", e));
    }
});

		 

        
        // Запуск игры через 100мс (даем время на загрузку)
        setTimeout(update, 100);
    </script>
</body>
</html>